// api/admin.js
const crypto = require('crypto');

// Global database simulation (in production, use real database)
global.keyDatabase = global.keyDatabase || new Map();
global.deviceBindings = global.deviceBindings || new Map();
global.usageLogs = global.usageLogs || [];

function generateRandomKey() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < 16; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// Initialize demo keys if empty
if (global.keyDatabase.size === 0) {
  const demoKeys = [
    {
      key: 'DEMO1234567890AB',
      createdAt: Date.now(),
      expiresAt: Date.now() + (30 * 24 * 60 * 60 * 1000),
      isActive: true,
      usageCount: 0,
      maxUsage: 1
    }
  ];
  
  demoKeys.forEach(key => {
    global.keyDatabase.set(key.key, key);
  });
}

export default async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  const { password } = req.query;
  
  if (password !== 'Whoamidev1819') {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  if (req.method === 'GET') {
    const keys = Array.from(global.keyDatabase.values()).map(key => ({
      key: req.query.showFull === 'true' ? key.key : key.key.substring(0, 8) + '...',
      createdAt: new Date(key.createdAt).toISOString(),
      expiresAt: new Date(key.expiresAt).toISOString(),
      isActive: key.isActive,
      usageCount: key.usageCount,
      maxUsage: key.maxUsage,
      deviceBound: !!key.deviceId
    }));
    
    return res.json({ 
      success: true, 
      keys: keys,
      stats: {
        totalKeys: global.keyDatabase.size,
        activeKeys: keys.filter(k => k.isActive).length,
        totalLogs: global.usageLogs.length
      }
    });
  }
  
  if (req.method === 'POST') {
    const { duration = 30, maxUsage = 1, customKey } = req.body || {};
    
    const newKey = {
      key: customKey || generateRandomKey(),
      userId: null,
      deviceId: null,
      createdAt: Date.now(),
      expiresAt: Date.now() + (duration * 24 * 60 * 60 * 1000),
      isActive: true,
      usageCount: 0,
      maxUsage: maxUsage
    };
    
    if (global.keyDatabase.has(newKey.key)) {
      return res.status(409).json({ error: 'Key already exists' });
    }
    
    global.keyDatabase.set(newKey.key, newKey);
    
    return res.json({
      success: true,
      key: newKey.key,
      expiresAt: newKey.expiresAt,
      maxUsage: newKey.maxUsage
    });
  }
  
  if (req.method === 'DELETE') {
    const { key } = req.body || {};
    
    if (!key) {
      return res.status(400).json({ error: 'Key required' });
    }
    
    if (global.keyDatabase.delete(key)) {
      global.deviceBindings.delete(key);
      return res.json({ success: true, message: 'Key deleted' });
    }
    
    return res.status(404).json({ error: 'Key not found' });
  }
  
  return res.status(405).json({ error: 'Method not allowed' });
}

// api/validate.js
const crypto = require('crypto');

// Use global database
global.keyDatabase = global.keyDatabase || new Map();
global.deviceBindings = global.deviceBindings || new Map();
global.usageLogs = global.usageLogs || [];

function generateDeviceFingerprint(userAgent, ip, deviceInfo = {}) {
  const fingerprint = {
    userAgent: userAgent || '',
    ip: (ip || '').split(',')[0].trim(), // Get first IP if multiple
    platform: deviceInfo.platform || '',
    executor: deviceInfo.executor || '',
    screen: deviceInfo.screen || '',
    hour: Math.floor(Date.now() / (1000 * 60 * 60)) // Hour precision for some variance
  };
  
  const combined = JSON.stringify(fingerprint);
  return crypto.createHash('sha256').update(combined).digest('hex');
}

export default async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }
  
  try {
    const { key, deviceInfo } = req.body || {};
    
    if (!key) {
      return res.status(400).json({ error: 'Key required' });
    }
    
    // Get key from database
    const keyData = global.keyDatabase.get(key);
    
    if (!keyData) {
      global.usageLogs.push({
        key: key,
        action: 'invalid_key_attempt',
        ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
        timestamp: Date.now(),
        suspicious: true
      });
      
      return res.status(404).json({ error: 'Invalid key' });
    }
    
    // Check expiration
    if (Date.now() > keyData.expiresAt) {
      return res.status(403).json({ error: 'Key expired' });
    }
    
    // Check active status
    if (!keyData.isActive) {
      return res.status(403).json({ error: 'Key deactivated' });
    }
    
    // Check usage limit
    if (keyData.usageCount >= keyData.maxUsage) {
      return res.status(403).json({ error: 'Usage limit exceeded' });
    }
    
    // Generate device fingerprint
    const currentDeviceId = generateDeviceFingerprint(
      req.headers['user-agent'],
      req.headers['x-forwarded-for'] || req.connection.remoteAddress,
      deviceInfo
    );
    
    // Check device binding
    const boundDeviceId = global.deviceBindings.get(key);
    
    if (!boundDeviceId) {
      // First time usage - bind device
      global.deviceBindings.set(key, currentDeviceId);
      keyData.deviceId = currentDeviceId;
      keyData.usageCount += 1;
      global.keyDatabase.set(key, keyData);
      
      global.usageLogs.push({
        key: key,
        deviceId: currentDeviceId,
        action: 'first_bind',
        ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
        timestamp: Date.now()
      });
      
      return res.json({ 
        success: true, 
        message: 'Key validated and device bound',
        remainingUses: keyData.maxUsage - keyData.usageCount,
        expiresAt: keyData.expiresAt
      });
    }
    
    // Verify device fingerprint
    if (boundDeviceId !== currentDeviceId) {
      global.usageLogs.push({
        key: key,
        deviceId: currentDeviceId,
        boundDeviceId: boundDeviceId,
        action: 'device_mismatch',
        ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
        timestamp: Date.now(),
        suspicious: true
      });
      
      return res.status(403).json({ 
        error: 'Device mismatch. This key is bound to another device.' 
      });
    }
    
    // Update usage
    keyData.usageCount += 1;
    global.keyDatabase.set(key, keyData);
    
    global.usageLogs.push({
      key: key,
      deviceId: currentDeviceId,
      action: 'successful_validation',
      ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
      timestamp: Date.now()
    });
    
    return res.json({ 
      success: true, 
      message: 'Key validated successfully',
      remainingUses: keyData.maxUsage - keyData.usageCount,
      expiresAt: keyData.expiresAt
    });
    
  } catch (error) {
    console.error('Validation error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

// api/logs.js
global.usageLogs = global.usageLogs || [];

export default async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  if (req.method === 'POST') {
    const logData = req.body || {};
    global.usageLogs.push({
      ...logData,
      timestamp: Date.now()
    });
    
    // Keep only last 1000 logs
    if (global.usageLogs.length > 1000) {
      global.usageLogs = global.usageLogs.slice(-1000);
    }
    
    return res.json({ success: true });
  }
  
  if (req.method === 'GET') {
    const { password, limit = 50, suspicious = false } = req.query;
    
    if (password !== 'Whoamidev1819') {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    
    let logs = global.usageLogs;
    
    if (suspicious === 'true') {
      logs = logs.filter(log => log.suspicious);
    }
    
    return res.json({
      success: true,
      logs: logs.slice(-parseInt(limit)).reverse(),
      total: logs.length
    });
  }
  
  return res.status(405).json({ error: 'Method not allowed' });
}

// api/status.js
export default async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Content-Type', 'application/json');
  
  return res.json({
    success: true,
    message: 'Delta Key System API is running',
    timestamp: new Date().toISOString(),
    endpoints: {
      validate: '/api/validate (POST)',
      admin: '/api/admin (GET/POST/DELETE)',
      logs: '/api/logs (GET/POST)',
      status: '/api/status (GET)'
    },
    version: '1.0.0'
  });
}
